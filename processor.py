
from collections import defaultdict
from datetime import datetime
import json
import requests # Used for the Gemini API call

def process_data_for_charts(records):
    """
    Processes raw flight records to extract data for price trends and popular routes.
    Args:
        records (list): A list of filtered flight records.
    Returns:
        tuple: (price_trends, popular_routes)
    """
    # 1. Price Trends Over Time
    price_by_date = defaultdict(lambda: {'total_price': 0, 'total_bookings': 0})
    for record in records:
        price_by_date[record['date']]['total_price'] += record['price'] * record['bookings']
        price_by_date[record['date']]['total_bookings'] += record['bookings']

    price_trends = []
    for date_str in sorted(price_by_date.keys()):
        total_price = price_by_date[date_str]['total_price']
        total_bookings = price_by_date[date_str]['total_bookings']
        avg_price = total_price / total_bookings if total_bookings > 0 else 0
        price_trends.append({'date': date_str, 'avg_price': round(avg_price, 2)})

    # 2. Popular Routes
    route_data = defaultdict(lambda: {'total_bookings': 0, 'total_price': 0, 'count': 0})
    for record in records:
        route = f"{record['origin']} to {record['destination']}"
        route_data[route]['total_bookings'] += record['bookings']
        route_data[route]['total_price'] += record['price'] * record['bookings']
        route_data[route]['count'] += record['bookings'] # Count of individual flight instances contributing to this route

    popular_routes = []
    for route, data in route_data.items():
        avg_price = data['total_price'] / data['count'] if data['count'] > 0 else 0
        popular_routes.append({
            'route': route,
            'bookings': data['total_bookings'],
            'avg_price': round(avg_price, 2)
        })

    # Sort popular routes by total bookings in descending order
    popular_routes = sorted(popular_routes, key=lambda x: x['bookings'], reverse=True)[:10] # Top 10 routes

    return price_trends, popular_routes

def summarize_data_for_llm(data):
    """
    Summarizes raw flight data into a format suitable for the LLM.
    Args:
        data (list): A list of raw flight records.
    Returns:
        dict: A summary of the data.
    """
    if not data:
        return {}

    summary = {
        "total_records": len(data),
        "date_range": f"{data[0]['date']} to {data[-1]['date']}" if data else "N/A",
        "top_origins": defaultdict(int),
        "top_destinations": defaultdict(int),
        "average_price": 0,
        "total_bookings": 0,
        "price_distribution": defaultdict(int), # e.g., price ranges
        "daily_bookings": defaultdict(int)
    }

    total_price_sum = 0
    for record in data:
        summary["top_origins"][record['origin']] += record['bookings']
        summary["top_destinations"][record['destination']] += record['bookings']
        total_price_sum += record['price'] * record['bookings']
        summary["total_bookings"] += record['bookings']
        summary["daily_bookings"][record['date']] += record['bookings']

        # Simple price distribution bins
        if record['price'] < 200: summary["price_distribution"]["<200"] += 1
        elif record['price'] < 400: summary["price_distribution"]["200-400"] += 1
        elif record['price'] < 600: summary["price_distribution"]["400-600"] += 1
        else: summary["price_distribution"][">600"] += 1

    if summary["total_bookings"] > 0:
        summary["average_price"] = round(total_price_sum / summary["total_bookings"], 2)

    # Convert defaultdicts to regular dicts and sort for better LLM input
    summary["top_origins"] = dict(sorted(summary["top_origins"].items(), key=lambda item: item[1], reverse=True)[:5])
    summary["top_destinations"] = dict(sorted(summary["top_destinations"].items(), key=lambda item: item[1], reverse=True)[:5])
    summary["daily_bookings"] = dict(sorted(summary["daily_bookings"].items())) # Sort by date

    return summary

async def get_gemini_insights(data_summary):
    """
    Calls the Gemini API to get insights from the provided data summary.
    Args:
        data_summary (dict): A summarized version of the airline booking data.
    Returns:
        str: The insights generated by the LLM, or an error message.
    """
    chat_history = []
    prompt = f"""Analyze the following airline booking data summary and provide concise insights on:
    1. Popular routes (mention top 3-5).
    2. Overall price trends (increasing, decreasing, stable, or fluctuating).
    3. High-demand periods or locations (specific dates, months, or cities).
    4. Any other interesting observations.

    Data Summary:
    {json.dumps(data_summary, indent=2)}

    Please provide a concise summary suitable for a business report.
    """
    chat_history.append({ "role": "user", "parts": [{ "text": prompt }] })

    # Placeholder for API key. In a real environment, this would be loaded securely.
    api_key = "AIzaSyANdra--Etp-7CpwxEvkma61cOOoFIuw50" # If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={api_key}"

    try:
        # Using requests for synchronous HTTP call. For async Flask, aiohttp would be better.
        headers = { 'Content-Type': 'application/json' }
        payload = { "contents": chat_history }
        response = requests.post(api_url, headers=headers, json=payload)
        response.raise_for_status() # Raise an exception for HTTP errors (4xx or 5xx)
        result = response.json()

        if result.get("candidates") and len(result["candidates"]) > 0 and \
           result["candidates"][0].get("content") and \
           result["candidates"][0]["content"].get("parts") and \
           len(result["candidates"][0]["content"]["parts"]) > 0:
            return result["candidates"][0]["content"]["parts"][0]["text"]
        else:
            return "No specific insights could be generated from the provided data structure by the AI."
    except requests.exceptions.RequestException as e:
        print(f"Error calling Gemini API: {e}")
        return f"Failed to get insights from AI due to network or API error: {e}. Please try again later."
    except Exception as e:
        print(f"An unexpected error occurred during AI insight generation: {e}")
        return "An unexpected error occurred while processing insights from the AI."
